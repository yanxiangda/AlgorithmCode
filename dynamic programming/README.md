# 动态规划部分

## longest-palindromic-subsequence
字符串的最长回文序列。
<br>
(1)动态规划思想，体现在最优值的规划上，如果当前字符串开头与结尾相同，那么最优值=2 + 去掉开头和结尾的子字符串的最长回文序列；如果不相等，那么是（去掉开头，去掉结尾）的最长子串，两者取最大。到这一步，能够AC65/83的测试用例。
<br>
(2)上面的动态规划思想还有优化的空间，即用内存代替一部分搜索时间，建立一个保存，把计算过的都保存下来，这样再遇到的时候避免重复计算。到这一步可以AC82/83的测试用例
<br>
(3)还有一个没AC，从代码上做小部分的优化即可以了，重点优化重复计算的变量，当变量被多次使用时，不要重复计算，比如,

    haveValue = recordResult[startIndex][endIndex]

替代后，效率有较大提升，可AC全部。
<br>
(4)注意边界条件，当字符串剩0个时候，和剩1个的时候。
<br>

## longest-palindromic-substring
字符串的最长回文子串
<br>
>这题有两种解决方法，一种是动态规划复杂度为$O(n^2)$，另一种是Manacher's Algorithm复杂度是$O(n)$，本部分只关注动态规划的思想，因为不适用马拉车的方法。
<br>
(1)与最长回文子序列不同，最长子串不存在一些"贪心"的思路，比如第一个和最后一个字母相同时，得到的解一定优于只去掉第一个或者只去掉最后一个的。比如'aababa'，去掉首尾后的'abab'不是子串，而只去掉首的'ababa'优于前一种。因此判断的时候要多加了一层，

    if ((strList[startIndex] == strList[endIndex]) & (self.localCalculate(strList, startIndex + 1, endIndex - 1, recordResult) == 1)):
        return 1

即只有两个条件同时满足时，才不用计算另两种情况。
<br>
(2)与第一种不同的是，最长子序列只要返回数量，如果要返回具体的字符串，需要一种优化方法，现在想的方法是在存储的二维结果数组中遍历最大，可能影响了一定的效率，动态规划方法只AC了38/103的测试用例。
<br>

## minimum-path-sum
最短路径和
<br>
(1)这题思路比较简单，从左上角的点出发，每次判断是否是边界的点，如果不是边界的点，就取向右的最优值和向下的最优值中最优的值+当前点的值。
<br>
(2)如果不用数组对计算过的数据进行缓存，能AC20/108左右，加入缓存的数据，可以在要求时间内AC全部。




