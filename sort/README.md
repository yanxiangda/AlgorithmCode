# 排序算法
| 算法类型 | 排序算法名称 | 时间复杂度 |
|:------:|:------:|:------:|
| 交换 | 冒泡排序 |  | 
| 交换 | 快速排序 | O(nlog(n)) |
| 插入 | 简单插入排序 |
| 插入 | 希尔排序 |
| 选择 | 简单选择排序 |
| 选择 | 堆排序 |
| 归并 | 二路归并排序 | O(nlog(n)) |
| 归并 | 多路归并排序 |
| 基数排序 | 基数排序 |
| 桶排序 | 桶排序 |



# 重要排序算法原理、关键点、实现
**1 快速排序 quick sort**<br>
（1）两个指针，分别指向第一个和最后一个元素，前面的指针向后移动搜索大于基准值的Index(基准值可以取第一个元素)，后面的指针向前移动搜索小于基准值的Index，然后将两者调换顺序。
<br>
（2）直到前后两个指针相遇在同一个元素上，进行判断，如果这个元素小于基准值，那么将这个相遇的元素和第一个值交换，否则，将这个相遇的元素的前一个元素和第一个值交换。
<br>
（3）注意的是，相遇时会发生多种情况，因此对索引进行控制，防止溢出, 如在递归中，
```python
quicksort(data, baseIndex, max(minIndex - 1, baseIndex))
quicksort(data, min(minIndex + 1, fixIndex), fixIndex)
```
**2 归并排序 merge sort**<br>
（1）归并排序首先要实现一个用于将两个有序数列合并为一个有序数列的方法，即代码中的`merge()`方法，该方法的实现逻辑，需要利用一个辅助的空间，先依次把两个有序数组中更小的取出来，对于没有取完的数组，直接全部取出，再降辅助空间的数据复制到原数组上。
<br>
（2）先拆分，再归并。
<br>
（3）注意的是，如果函数是采用索引形式的，那么`midIndex`要计算的是索引，要加上`startIndex`，
```python
midIndex = start + int((size) / 2)
```
**3 堆排序**<br>



# 衡量算法的标准
（1）稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
<br>
（2）不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
<br>
（3）时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
<br>
（4）空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 